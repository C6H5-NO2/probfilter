import probfilter.verifx.filter.GBloomFilter
import probfilter.verifx.lemma.CvRDT
import probfilter.verifx.lemma.CvRDTProof
import probfilter.verifx.util.Complex


class SubFilter(filter: GBloomFilter) extends CvRDT[SubFilter] {
  override def reachable(): Boolean = this.filter.reachable()

  override def compatible(that: SubFilter): Boolean = this.filter.compatible(that.filter)

  def merge(that: SubFilter): SubFilter = new SubFilter(this.filter.merge(that.filter))

  def compare(that: SubFilter): Boolean = this.filter.compare(that.filter)
}

class ScalableFilterSeries(series: Vector[SubFilter]) extends CvRDT[ScalableFilterSeries] {
  override def reachable(): Boolean = {
    this.series.wellFormed() && this.series.forall((sf: SubFilter) => sf.reachable())
  }

  override def compatible(that: ScalableFilterSeries): Boolean = {
    this.series.positions.zip(that.series.positions).values().forall((tup: Tuple[SubFilter, SubFilter]) => tup.fst.compatible(tup.snd))
  }

  def merge(that: ScalableFilterSeries): ScalableFilterSeries = {
    val size = if (this.series.size > that.series.size) this.series.size else that.series.size
    val positions = this.series.positions.combine(that.series.positions, (fst: SubFilter, snd: SubFilter) => fst.merge(snd))
    new ScalableFilterSeries(new Vector[SubFilter](size, positions))
  }

  def compare(that: ScalableFilterSeries): Boolean = {
    this.series.size <= that.series.size &&
      this.series.zip(that.series).forall((tup: Tuple[SubFilter, SubFilter]) => tup.fst.compare(tup.snd))
  }
}

object ScalableFilterSeries extends CvRDTProof[ScalableFilterSeries]
